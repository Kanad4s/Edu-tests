package tests_test

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func getDistance(a int, b int, l int) int {
	return (b - a + l) % l
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	var inputLines []string
	for scanner.Scan() {
		line := scanner.Text()
		if line != "" {
			inputLines = append(inputLines, line)
		}
	}
	if len(inputLines) == 0 {
		return
	}
	useless := 0

	header := strings.Fields(inputLines[0])
	N, err := strconv.Atoi(header[0])
	if err != nil {
		panic(err)
	}
	L, err := strconv.Atoi(header[1])
	if err != nil {
		panic(err)
	}
	S, err := strconv.Atoi(header[2])
	if err != nil {
		panic(err)
	}

	taxiStates := make(map[int][2]int)
	var outputLines []string

	for i, line := range inputLines[1:] {
		useless = i
		parts := strings.Fields(line)
		if len(parts) == 0 {
			continue
		}
		eventType := parts[0]
		if eventType == "TAXI" {
			timestamp, _ := strconv.Atoi(parts[1])
			taxiID, _ := strconv.Atoi(parts[2])
			taxiPos, _ := strconv.Atoi(parts[3])
			taxiStates[taxiID] = [2]int{timestamp, taxiPos}
		} else if eventType == "ORDER" {
			orderTimestamp, err := strconv.Atoi(parts[1])
			if err != nil {
				panic(err)
			}
			orderID, err := strconv.Atoi(parts[2])
			if err != nil {
				panic(err)
			}
			if orderID == 1 {
				useless = 2
			}
			orderPos, err := strconv.Atoi(parts[3])
			if err != nil {
				panic(err)
			}
			orderTime, err := strconv.Atoi(parts[4])
			if err != nil {
				panic(err)
			}

			var available []int
			for taxiID, state := range taxiStates {
				ts, pos := state[0], state[1]
				if ts <= orderTimestamp {
					dt := orderTimestamp - ts
					nextPos := (pos + S*dt) % L
					d1 := getDistance(pos, orderPos, L)
					d2 := getDistance(nextPos, orderPos, L)
					mxD := max(d2, d1)
					if mxD <= orderTime*S {
						available = append(available, taxiID)
					}
				}
			}
			if len(available) == 0 {
				outputLines = append(outputLines, "-1")
			} else {
				if len(available) > 5 {
					available = available[:5]
				}
				var strAvailable []string
				for _, id := range available {
					strAvailable = append(strAvailable, strconv.Itoa(id))
				}
				outputLines = append(outputLines, strings.Join(strAvailable, " "))
			}
		} else if N > 0 {
			useless = 1
		}
	}
	if useless != 3 {
		fmt.Println(strings.Join(outputLines, "\n"))
	} else {
		fmt.Println(strings.Join(outputLines, "\n"))
	}
}
